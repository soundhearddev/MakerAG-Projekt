<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipes.html</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #0a0a0a;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #canvas {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
        }

        .message {
            position: relative;
            z-index: 10;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 2rem;
            text-align: center;
            cursor: pointer;
            user-select: none;
            animation: pulse-glow 2s ease-in-out infinite;
        }

        @keyframes pulse-glow {

            0%,
            100% {
                text-shadow:
                    0 0 30px rgba(255, 100, 150, 0.8),
                    0 0 60px rgba(100, 200, 200, 0.6),
                    0 5px 20px rgba(0, 0, 0, 0.6);
            }

            50% {
                text-shadow:
                    0 0 40px rgba(255, 100, 150, 1),
                    0 0 80px rgba(100, 200, 200, 0.8),
                    0 5px 25px rgba(0, 0, 0, 0.7);
            }
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div class="message" id="message">Click to Start</div>

    <script>
        (function initPipes() {
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
            const message = document.getElementById("message");

            const CELL = 4;
            const SPEED = 30;
            const PIPE_COUNT = 30;
            const YELLOW_DELAY = 10000; // Gelb kommt nach 3 Sekunden
            const FADE_SPEED = 0.002; // Wie schnell Pipes verblassen
            let startTime = 0;
            let hasYellowPipe = false; // Verfolgt ob gelbe Pipe existiert
            let grid = {}; // Speichert gezeichnete Pixel mit ihrer Opacity
            const DIRS = [
                { x: 1, y: 0 },
                { x: -1, y: 0 },
                { x: 0, y: 1 },
                { x: 0, y: -1 }
            ];

            let COLS = 0;
            let ROWS = 0;
            let pipes = [];
            let running = false;
            let lastFrame = 0;
            let animationId = null;

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                COLS = Math.floor(canvas.width / CELL);
                ROWS = Math.floor(canvas.height / CELL);

                if (running) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }

            window.addEventListener("resize", resize);
            resize();

            function rand(max) {
                return Math.floor(Math.random() * max);
            }

            class Pipe {
                constructor() {
                    this.size = 1; // Standard-Größe
                    this.isYellow = false;
                    this.reset();
                }

                reset() {
                    // Wenn diese Pipe gelb war, setze Flag zurück
                    if (this.isYellow) {
                        hasYellowPipe = false;
                        this.isYellow = false;
                    }

                    const spawnMode = rand(4);

                    if (spawnMode === 0) {
                        this.x = 0;
                        this.y = rand(ROWS);
                    } else if (spawnMode === 1) {
                        this.x = COLS - 1;
                        this.y = rand(ROWS);
                    } else if (spawnMode === 2) {
                        this.x = rand(COLS);
                        this.y = 0;
                    } else {
                        this.x = rand(COLS);
                        this.y = ROWS - 1;
                    }

                    this.dir = DIRS[rand(4)];

                    // Prüfe ob Gelb erlaubt ist (nach Verzögerung UND wenn noch keine gelbe Pipe existiert)
                    const elapsed = performance.now() - startTime;

                    if (elapsed >= YELLOW_DELAY && !hasYellowPipe && Math.random() < 0.3) {
                        // Gelbe Pipe erstellen (nur wenn noch keine existiert)
                        this.color = 'hsla(47, 100%, 71%, 0.9)';
                        this.size = 10;
                        this.isYellow = true;
                        hasYellowPipe = true;
                    } else {
                        // Rot oder Türkis
                        const colors = [
                            'hsla(358, 100%, 70%, 0.9)',  // rot/pink
                            'hsla(177, 62%, 60%, 0.9)'    // türkis
                        ];
                        this.color = colors[rand(2)];
                        this.size = 1;
                        this.isYellow = false;
                    }
                }

                step() {
                    if (Math.random() < 0.2) {
                        this.dir = DIRS[rand(4)];
                    }

                    const nx = this.x + this.dir.x;
                    const ny = this.y + this.dir.y;

                    if (nx < 0 || ny < 0 || nx >= COLS || ny >= ROWS) {
                        this.reset();
                        return;
                    }

                    // Speichere gezeichnete Pixel im Grid
                    const key = `${this.x},${this.y}`;
                    grid[key] = {
                        color: this.color,
                        opacity: 0.9,
                        size: this.size
                    };

                    this.x = nx;
                    this.y = ny;
                }
            }

            function startPipes() {
                if (running) return;

                running = true;
                startTime = performance.now(); // Startzeit merken
                hasYellowPipe = false; // Reset yellow pipe flag
                grid = {}; // Grid zurücksetzen
                message.style.fontSize = '100px';
                message.style.cursor = 'none'
                message.innerHTML = 'MAKER AG'
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                pipes = [];

                for (let i = 0; i < PIPE_COUNT; i++) {
                    pipes.push(new Pipe());
                }

                lastFrame = performance.now();
            }

            message.addEventListener("click", startPipes);
            canvas.addEventListener("click", startPipes);

            function loop(ts) {
                if (running && ts - lastFrame > SPEED) {
                    // Canvas leeren
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Alte Pipes verblassen lassen und zeichnen
                    for (let key in grid) {
                        const pixel = grid[key];

                        // Opacity reduzieren
                        pixel.opacity -= FADE_SPEED;

                        // Wenn komplett transparent, aus Grid entfernen
                        if (pixel.opacity <= 0) {
                            delete grid[key];
                            continue;
                        }

                        // Pixel mit aktueller Opacity zeichnen
                        const [x, y] = key.split(',').map(Number);
                        const colorMatch = pixel.color.match(/hsla\((\d+),\s*(\d+)%,\s*(\d+)%/);
                        if (colorMatch) {
                            const [, h, s, l] = colorMatch;
                            ctx.fillStyle = `hsla(${h}, ${s}%, ${l}%, ${pixel.opacity})`;
                            ctx.shadowBlur = 10 * pixel.size * pixel.opacity;
                            ctx.shadowColor = ctx.fillStyle;
                            ctx.fillRect(x * CELL, y * CELL, CELL * pixel.size, CELL * pixel.size);
                            ctx.shadowBlur = 0;
                        }
                    }

                    // Pipes bewegen
                    pipes.forEach(p => p.step());
                    lastFrame = ts;
                }

                animationId = requestAnimationFrame(loop);
            }

            animationId = requestAnimationFrame(loop);

            window.addEventListener("beforeunload", () => {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            });
        })();
    </script>
</body>

</html>